
이미지 후처리의 대표적인 방식.

최신 그래픽스 파이프라인은 결국 마지막에 이미지처리를 수행하게 됨. 즉 중요한 부분임.

이하 내용은 홍정모 그래픽스 part 1. chapter 2의 내용을 바탕으로 함. 

---
# Kernel

커널이란 이미지에 적용하는 필터의 일종, 적용하는 것으로 이미지의 특정 요소를 강조할 수 있다.
선명하게(sharpen), 윤곽선 강조(ridge), 희미하게(Blur) 등 여러 효과를 준다.

---
# Convolution
커널은 정방형 행렬로 표현되며, 이러한 kernel의 적용을 convolution이라 한다. 그 적용 과정은 target이 되는 중심 픽셀의 값을 주변 픽셀의 값과 그에 대응되는 커널의 값을 곱하고, 이를 모두 더해서 결정한다. 
```C++
constexpr float gaussianKernel[3][3] = {
			{1, 2, 1},
			{2, 4, 2},
			{1, 2, 2}};

constexpr float image[12][12] = {
			{1, 2, 3, 4, 5, ...},
			{0, 1, 2, 4, 4, ...},
			{3, 6, 7, 4, 5, ...},
			{....}
};

float result[12][12];

result[1][1] = [&](int tY, tX) -> int {
	int sum = 0;
	for (int r = 0; r < 3; ++r)
	{
		for (int c = 0; c < 3; ++c)
		{
			sum += gaussianKernel[r][c] * image[tY - 1 + r][tX - 1 + c]; 
		}
	}
	return sum / 16;  // 잊지 말고 반드시 나눠줘야 함.
}(1, 1);

```

위 예제 코드에서는 0-indexed 2차원 배열로 표현된 이미지에 3X3 가우시안 블러 커널의 컨벌루션을 표현했다. 형태가 행렬로 표현될 뿐, 실제 컨볼루션의 동작은 행렬과는 다르다.

위 예제에서는 타겟이 1,1인 경우에 대해서 보여주고 있는데, 그렇다면 0,0 등 주변 픽셀이  out-of-range가 되는 경우에 커널에 상응하는 픽셀의 값이 없는 문제가 생긴다. 보통, 가장 가까운 픽셀에서 값을 빌려오는 것으로 해결한다.

### Seperable Convolution

앞서 살펴본 컨볼루션은 2차원 행렬로 표현되는 2D 컨볼루션이다. 하지만 컴퓨터 그래픽스에서는 효율성 등의 문제로 Seperable Convolution이라는 기법을 사용한다.

seperable convolution은 2차원 컨볼루션의 연산량 문제를 해결하기 위해서 1차원 커널을 가로, 세로 2번을 적용하여 2차원 컨볼루션을 구현한다.
### Box Blur

주변 8개 픽셀을 포함하는 9개 픽셀의 평균을 자신의 값으로 삼는다.
이는 seperable convolution도 마찬가지여서 선형 커널의, 직선상의 값들의 단순 평균을 취한다.

### Gaussian Blur

단순 평균을 적용하는 Box Blur와 달리, 중심이 되는 픽셀에 가까울수록 보다 강한 효과를 내도록 가중치를 두어 필터링한다.

위에서 보였던 2차원 커널과는 달리, seperable kernel 효과를 주게 되면 특정한 가중치 값을 필요로 한다. 크기 5인 1차원 가우시안 커널의 경우, 그 가중치는 {0.0545, 0.2442, 0.4026, 0.2442, 0.0545}가 된다.

---

# Bloom

블룸이란 빛의 퍼짐 효과를 부여하여 조명의 영향만 선택적으로 강조하는 효과이다.
그 구현을 위해서 가우시안 블러가 사용된다.

1. 빛의 퍼짐 적용
	- 충분히 밝은 픽셀에 대하여 가우시안 블러를 적용하여 빛의 퍼짐을 얻음.
	- 밝기의 정도는 Relative Luminance라는 실험값을 통해서 결정.
2. 블러처리된 이미지와 원본 이미지를 합성하여 블룸 효과를 적용함.


